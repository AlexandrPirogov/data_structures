# Графы

Граф -- структура данных, состоящя из множества вершин `V` и множества ребер `E`, соедияющие вершины.
Граф очень гибкая структура данных в плане решения задач: от планирования, до оптимизации.

## Виды графов

Графы могут быть:
1) Ориентированные. Формально говоря, если `u → v`, то `v → u`, при условии, что `u` и `v` ∈ `У`
1) Направленные. Формально говоря, если `u -> v`, то не это не означает, что  `v → u`

Графы могут быть:
1) Невзешенными. Формально говоря, вес всех ребер эквивалентен
2) Взвешенный. Ребрам даны различные веса.


Графы могут быть:
1) Полными. Количество вершин равно `(n*(n-1))/2`, где n -- количество вершин в графе.
2) Плотными. Не полный, но заполненность ребрами больше 50% (проценты условные)
3) Разреженными.  Заполненность ребрами менее 50%.

Плотность графа может влиять не только на выбо реализации, но и на выбор алгоритма.

## Реализация

Графы могут быть реализованы с помощью:

| Реализация            | Сложность по памяти  |  Когда выбирать            |
|:---------------------:|:--------------------:|:--------------------------:|
| Матрца смежности      | `O(\|V\|^2)`         | Граф плотный или почти плотный. Большинство операций: добавление/удаление ребер; проверить,с межности вершин                                      |
| Список смежности      | `O(\|V\|+\|E\|)`     | Если предполагается частое удаление/добавление вершин, обход графа. В большинстве случаев, если не подходит матрица, выбирайте данную реализацию. |

### Сложность операций


| Реализация            |  Добавление вершины  |  Удаление вершины|   Добавление ребра | Удаление ребра | Проверить смежность вершин |
|:---------------------:|:--------------------:|:----------------:|:------------------:|:--------------:|:--------------------------:|
| Матрца смежности      | `O(\|V\|^2)`         |  `O(\|V\|^2)`    |    `O(1)`          |   `O(1)`       |   `O(1)`                   |
| Список смежности      | `O(1)`               |   `O(\|E\|)`     |   `O(1)`           |    `O(1)`      |   `O(\|E\|)`               |

# Основные алгоритмы

## Обход графа

В общем случае все алгоритмы обхода можно расписать следующем образом:

```
SomeFirstSearch(s):
put s into the bag
while the bag is not empty
  take v from the bag
  if v is unmarked
    mark v
    for each edge vw
        put w into the bag
```

Например, для реализации обхода в ширину, подставьте вместо `bag` - `queue`, а для поиска в глубину, подставьте вместо `bag` - `stack`.
Вместо `bag` можно добавить также `очередь с приоритетом` - при небольшой модификации, можно получить `алгоритм Ярника-Прима`.

| Обход | Сложность по памяти | Временная сложность  |
|:-----:|:-------------------:|:--------------------:|
| `DFS` |    `O(\|V\|)`       |  `O(\|E\|+\|V\|)`    |
| `BFS` |    `O(\|V\|)`       |  `O(\|E\|+\|V\|)`    |

## Обход в глубину

Немного подробнее о DFS. Дело в том, что данный обход графа обладает свойствами, которые важны для понимания. 
Любая вершина графа при обходе может быть в одном из следующих состояний:
1) Новая. Функция DFS(v) ещё не была вызвана для этой вершины
2) Активная. Функция DFS(v) была вызвана для v, но ещё не была завершена/возврата из нее не было
3) Завершенная. Функция DFS(v) для вершины v была возвращена.

Алгоритм `DFS` выглядит следующим образом:

```
DFSAll(G):
   PreProcess(G)
   for all vertices v
      unmark v
   for all vertices v
      if v is unmarked
         DFS(v)

DFS(v):
   mark v
   PreVisit(v)
   for each edge/adj_vertex vw
      if w is unmarket
         parent(w) ← v
         DFS(w)
   PostVisit(v)
``` 

Что это дает на практике? :)

### Топологическая сортировка

Если направленный граф ациклический, то обход в глубину формирует топологический порядок завершенных вершин.

### Обнаружение циклов

Если во времея обхода мы встречаем вершину, которая ещё `активная`, то мы определили, что граф содержит цикл.

Тут можно посмтреть и с другой стороны: если мы зафиксируем время посещения вершин и классифицируем ребра графа, то если 
мы наткнемся на обратное ребро, то считай, что обнаружили цикл.


## Компоненты графа. 

Граф называется `сильно-связанный`, если существует путь для двух любых вершин
Граф может содержать так называемые `компоненты связности` -- подграфы графа, включают в себя `сильно-связанные` вершины.
Многие задачи сводятся к определению и подсчету компонентов графа. 

Чтобы посчитать компоненты графа, достаточно для каждой непомеченной вершины вызвать `DFS(v)`.

Чтобы определить `сильно-связные` компненты, можно воспользоваться `алгоритмом Тарьяна`.

##  [Алгоритм Тарьяна](https://www.youtube.com/watch?v=wUgWX0nc4NY)

Смысл заключается в отметке времени посещений вершин и присвоении по мере посещения вершин минимальной метки. Таким образом, мы находим 
сильно-связанные компоненты за линейной время.


## Минимальное остовное дерево

Также встречаются задачи для формирования остовного дерева -- ацикличного графа, который связывает все его вершины.
Для невзешенного графа достаточно воспользоваться `DFS(v)`.

Для взвешенного графа часто требуется сформировать минимальное остовное дерево. Мета-алгоритм таков:
```
Допустим, что F -- минимальное остовное дерево для графа G.
Следовательно, если нужно строить дерево F таким образом, чтобы оно было минимальным.
```

Звучит абстркатно, но суть будет ясна далее. Граф состоит из |V| вершин, которые для F представляются как лес деревьев. 
При построении дерева F, нужно следовать следующему правилу:

```
Добавляем в F только ребра, один конец которых есть компонент F, а другое -- нет. Выбираем ребра с минимальным весом
```

Таким образом, вся задача сводится к выбору нужных ребер и построению подграфа F.

Для этого есть алгоритм `Ярника-Прима`.
